package main

import (
	"context"
	"log"
	"net"
	"os"
	"os/signal"
	"path/filepath"
	"syscall"

	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/rlimit"
)

const (
	bpffsPath = "bpffs"
	device    = "eth0"
)

// vmlinux.h is generated by command "bpftool btf dump file /sys/kernel/btf/vmlinux format c "
//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc clang xdp_lb ./kern/xdp_lb.c -- -D__TARGET_ARCH_x86 -I../ebpf_headers -Wall

var obj xdp_lbObjects

func main() {
	ifiDev, err := net.InterfaceByName(device)
	if err != nil {
		log.Fatalf("Failed to fetch device info of %s: %v", device, err)
	}
	if err := rlimit.RemoveMemlock(); err != nil {
		log.Fatalf("Failed to remove rlimit memlock: %v", err)
	}
	os.MkdirAll(bpffsPath, os.ModeDir)
	checkBpffs()

	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()
	if err := loadXdp_lbObjects(&obj, nil); err != nil {
		log.Fatalf("Failed to load bpf obj: %v", err)
	}
	defer obj.Close()

	xdp, err := link.AttachXDP(link.XDPOptions{
		Program:   obj.xdp_lbPrograms.XdpLoadBalancer,
		Interface: ifiDev.Index,
		Flags:     link.XDPGenericMode,
	})
	if err != nil {
		log.Fatalf("Failed to attach xdp_tailcall to %s: %v", device, err)
	}
	defer xdp.Close()

	devPinPath := filepath.Join(bpffsPath, device)
	if err := xdp.Pin(devPinPath); err != nil {
		log.Fatalf("Failed to pin xdp_tailcall to %s: %v", device, err)
	}

	log.Printf("xdp_tailcall is running on %s\n", device)

	<-ctx.Done()
}

func checkBpffs() {
	_ = os.Mkdir(bpffsPath, 0o700)
	mounted, _ := IsMountedAt(bpffsPath)
	if mounted {
		return
	}

	err := MountAt(bpffsPath)
	if err != nil {
		log.Fatalf("Failed to mount -t bpf %s: %v", bpffsPath, err)
	}
}
